import 'dart:io';
import 'dart:typed_data';
import 'package:fiscalisation_rev/services/zimra_api_client.dart';
import 'package:path_provider/path_provider.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:pointycastle/api.dart';
import 'package:pointycastle/asymmetric/api.dart';
import 'package:pointycastle/asymmetric/rsa.dart';
import 'package:pointycastle/ecc/api.dart';
import 'package:pointycastle/key_derivators/api.dart';
import 'package:pointycastle/key_derivators/pbkdf2.dart';
import 'package:pointycastle/key_generators/api.dart';
import 'package:pointycastle/key_generators/rsa_key_generator.dart';
import 'package:pointycastle/macs/hmac.dart';
import 'package:pointycastle/digests/sha1.dart';
import 'package:pointycastle/digests/sha256.dart';
import 'package:pointycastle/block/aes.dart';
import 'package:pointycastle/block/modes/cbc.dart';
import 'package:asn1lib/asn1lib.dart';
import 'package:convert/convert.dart';
import 'package:pointycastle/signers/rsa_signer.dart'; // For hex encoding/decoding

// --- Simplified PKCS#12 Parsing (Conceptual and Basic) ---
// This is NOT a full-featured, robust PKCS#12 parser.
// It's designed to work for common cases generated by OpenSSL for testing.
// For production, consider a more robust solution (FFI to OpenSSL, etc.).

class Pkcs12Parser {
  static AsymmetricKey? parse(Uint8List p12Bytes, String password) {
    try {
      final asn1Parser = ASN1Parser(p12Bytes);
      final pfx = asn1Parser.nextObject() as ASN1Sequence;

      // Version (should be 3)
      // final version = (pfx.elements![0] as ASN1Integer).intValue;

      // AuthSafe
      final authSafe = pfx.elements![1] as ASN1Sequence;
      final contentType =
          (authSafe.elements![0] as ASN1ObjectIdentifier)
              .identifier; // Should be 1.2.840.113549.1.7.1 (data)

      final content = (authSafe.elements![1] as ASN1OctetString).contentBytes();
      final contentParser = ASN1Parser(content);
      final contentInfo =
          contentParser.nextObject() as ASN1Sequence; // ContentInfo sequence

      final signedData =
          contentInfo.elements![1] as ASN1Sequence; // SignedData sequence
      final encContentInfo =
          signedData.elements![1] as ASN1Sequence; // EncapsulatedContentInfo
      final octetString =
          encContentInfo.elements![1]
              as ASN1OctetString; // Octet string containing the actual PDU

      final pduBytes = octetString.contentBytes();
      final pduParser = ASN1Parser(pduBytes);
      final pduSequence =
          pduParser.nextObject() as ASN1Sequence; // PDU sequence

      // Iterate through the PDU sequence to find the ShroudedKeyBag
      for (final element in pduSequence.elements!) {
        if (element is ASN1Sequence) {
          final bagId =
              (element.elements![0] as ASN1ObjectIdentifier).identifier;
          // ShroudedKeyBag OID: 1.2.840.113549.1.12.10.1.2
          if (bagId == '1.2.840.113549.1.12.10.1.2') {
            final shroudedKeyBag = element.elements![1] as ASN1Sequence;
            final pkcs8ShroudedKeyBag =
                shroudedKeyBag.elements![1] as ASN1Sequence;

            final encryptionInfo =
                pkcs8ShroudedKeyBag.elements![0] as ASN1Sequence;
            final algorithmOid =
                (encryptionInfo.elements![0] as ASN1ObjectIdentifier)
                    .identifier;
            final params = encryptionInfo.elements![1] as ASN1Sequence;

            final encryptedKey =
                pkcs8ShroudedKeyBag.elements![1] as ASN1OctetString;
            final encryptedKeyBytes = encryptedKey.contentBytes();

            // --- Decryption Logic ---
            // This is a very basic decryption for common PBEWithSHA1AndAES128-CBC
            // You might need to extend this for other algorithms.
            if (algorithmOid == '1.2.840.113549.1.12.1.6') {
              // pbeWithSHA1AndRC2-CBC (common in older P12)
              // This is just an example, actual decryption depends on the algorithm
              // and parameters. This part is highly specific to the PBE algorithm used.
              // For AES-CBC, you'd need IV and salt.
              // This is where a proper crypto library would handle PBE.
              debugPrint(
                'PKCS#12: Found PBEWithSHA1AndRC2-CBC, not fully implemented for decryption.',
              );
              return null; // Not implemented for this example
            } else if (algorithmOid == '2.16.840.1.101.3.4.1.2') {
              // aes128-CBC
              // This is a common one for modern P12s, often combined with PBKDF2
              // Parameters for AES-CBC: IV
              final iv =
                  (params.elements![1] as ASN1OctetString).contentBytes();
              final salt =
                  (params.elements![0] as ASN1OctetString).contentBytes();
              final iterations = (params.elements![2] as ASN1Integer).intValue;

              // PBKDF2 for key derivation
              final pbkdf2 = PBKDF2KeyDerivator(HMac(SHA1Digest(), 64));
              pbkdf2.init(
                Pbkdf2Parameters(salt, iterations, 16),
              ); // 16 bytes for AES128
              final keyBytes = pbkdf2.process(
                Uint8List.fromList(password.codeUnits),
              );

              final cipher = CBCBlockCipher(AESEngine());
              cipher.init(false, ParametersWithIV(KeyParameter(keyBytes), iv));

              final paddedLength =
                  (encryptedKeyBytes.length ~/ cipher.blockSize) *
                  cipher.blockSize;
              final decryptedBytes = Uint8List(paddedLength);
              var offset = 0;
              while (offset < paddedLength) {
                offset += cipher.processBlock(
                  encryptedKeyBytes,
                  offset,
                  decryptedBytes,
                  offset,
                );
              }

              // Remove PKCS7 padding
              final padLength = decryptedBytes.last;
              final unpadded = decryptedBytes.sublist(
                0,
                decryptedBytes.length - padLength,
              );

              // Now parse the decrypted bytes as a PKCS#8 PrivateKeyInfo
              final pkcs8Parser = ASN1Parser(decryptedBytes);
              final pkcs8 = pkcs8Parser.nextObject() as ASN1Sequence;

              final privateKeyAlgorithm =
                  (pkcs8.elements![1] as ASN1Sequence).elements![0]
                      as ASN1ObjectIdentifier;
              final privateKeyBytes =
                  (pkcs8.elements![2] as ASN1OctetString).contentBytes();

              // Try to parse as RSA
              if (privateKeyAlgorithm.identifier == '1.2.840.113549.1.1.1') {
                // rsaEncryption
                final rsaParser = ASN1Parser(privateKeyBytes);
                final rsaSequence = rsaParser.nextObject() as ASN1Sequence;

                final modulus =
                    (rsaSequence.elements![1] as ASN1Integer).intValue;
                final publicExponent =
                    (rsaSequence.elements![2] as ASN1Integer).intValue;
                final privateExponent =
                    (rsaSequence.elements![3] as ASN1Integer).intValue;
                final p = (rsaSequence.elements![4] as ASN1Integer).intValue;
                final q = (rsaSequence.elements![5] as ASN1Integer).intValue;

                return RSAPrivateKey(
                  modulus as BigInt,
                  privateExponent as BigInt,
                  p as BigInt?,
                  q as BigInt?,
                );
              }
              // Try to parse as ECC
              else if (privateKeyAlgorithm.identifier == '1.2.840.10045.2.1') {
                // ecPublicKey
                // This is more complex as it involves parsing the EC private key structure
                // and potentially named curves.
                debugPrint(
                  'PKCS#12: Found EC private key, parsing not fully implemented for this example.',
                );
                return null;
              }
            }
          }
        }
      }
    } catch (e, st) {
      debugPrint('PKCS#12 Parsing Error: $e\n$st');
      return null;
    }
    return null;
  }
}

// --- End Simplified PKCS#12 Parsing ---

class CertificateManager {
  static const String _certFileName = 'zimra_client_cert.p12';
  static const String _passwordFileName = 'zimra_cert_password.txt';

  String? _certificatePath;
  String? _certificatePassword;
  SecurityContext? _securityContext;
  AsymmetricKey? _signingPrivateKey; // PointyCastle private key for signing

  bool get isReady => _securityContext != null && _signingPrivateKey != null;
  SecurityContext? get securityContext => _securityContext;
  AsymmetricKey? get signingPrivateKey => _signingPrivateKey;

  Future<bool> initialize() async {
    final appDir = await getApplicationDocumentsDirectory();
    final certFile = File('${appDir.path}/$_certFileName');
    final passwordFile = File('${appDir.path}/$_passwordFileName');

    if (await certFile.exists() && await passwordFile.exists()) {
      _certificatePath = certFile.path;
      _certificatePassword = await passwordFile.readAsString();
      return _loadCertificate();
    }
    return false;
  }

  Future<bool> _loadCertificate() async {
    if (_certificatePath == null || _certificatePassword == null) {
      return false;
    }

    try {
      final p12Bytes = await File(_certificatePath!).readAsBytes();

      // --- Load for SecurityContext (TLS) ---
      _securityContext = SecurityContext.defaultContext;
      _securityContext!.setClientAuthoritiesBytes(
        p12Bytes,
      ); // Not strictly needed for client, but good practice
      _securityContext!.useCertificateChainBytes(p12Bytes);
      _securityContext!.usePrivateKeyBytes(
        p12Bytes,
        password: _certificatePassword,
      );

      // --- Parse for PointyCastle Private Key (Signing) ---
      _signingPrivateKey = Pkcs12Parser.parse(p12Bytes, _certificatePassword!);
      if (_signingPrivateKey == null) {
        debugPrint('Failed to extract private key from P12 for signing.');
        _securityContext = null; // Invalidate if signing key can't be extracted
        return false;
      }

      debugPrint('Certificate and Private Key loaded successfully.');
      return true;
    } catch (e, st) {
      debugPrint('Error loading certificate: $e\n$st');
      _securityContext = null;
      _signingPrivateKey = null;
      return false;
    }
  }

  Future<bool> importCertificate(String password) async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['p12', 'pfx'],
      );

      if (result != null && result.files.single.path != null) {
        final appDir = await getApplicationDocumentsDirectory();
        final targetCertFile = File('${appDir.path}/$_certFileName');
        final targetPasswordFile = File('${appDir.path}/$_passwordFileName');

        await File(result.files.single.path!).copy(targetCertFile.path);
        await targetPasswordFile.writeAsString(password);

        _certificatePath = targetCertFile.path;
        _certificatePassword = password;

        return _loadCertificate();
      }
      return false;
    } catch (e, st) {
      debugPrint('Error importing certificate: $e\n$st');
      return false;
    }
  }

  // --- New: Generate CSR and Register Device ---
  // This method will be called from CertificateSetupDialog
  Future<Map<String, String>?> generateCsrAndRegisterDevice({
    required int deviceId,
    required String activationKey,
    required String deviceSerialNo,
    required String password, // Password for the new private key
  }) async {
    try {
      // 1. Generate a new RSA 2048 private key
      final keyGen = RSAKeyGenerator();
      keyGen.init(
        ParametersWithRandom(
          RSAKeyGeneratorParameters(BigInt.parse('65537'), 2048, 64),
          SecureRandom(),
        ),
      );
      final keyPair = keyGen.generateKeyPair();
      final RSAPrivateKey privateKey = keyPair.privateKey as RSAPrivateKey;
      final RSAPublicKey publicKey = keyPair.publicKey as RSAPublicKey;

      // 2. Build the CSR (simplified, only CN for now)
      // ZIMRA-<Fiscal_device_serial_no>-<zero_padded_10_digit_deviceId>
      final paddedDeviceId = deviceId.toString().padLeft(10, '0');
      final commonName = 'ZIMRA-$deviceSerialNo-$paddedDeviceId';

      // This is a very basic CSR structure. A full CSR would involve more ASN.1
      // encoding for attributes, etc. For ZIMRA, CN is the most critical.
      // This part is still somewhat simplified compared to a full X.509 CSR.
      // You might need to use a more robust CSR builder if this fails.
      final csrBuilder = ASN1Sequence();
      csrBuilder.add(ASN1Integer(BigInt.from(0))); // Version 0
      final subject = ASN1Sequence();
      final cn = ASN1Sequence();
      cn.add(ASN1ObjectIdentifier('2.5.4.3' as List<int>)); // CN OID
      cn.add(ASN1UTF8String(commonName));
      subject.add(cn);
      csrBuilder.add(subject);

      final spki = ASN1Sequence();
      final alg = ASN1Sequence();
      alg.add(
        ASN1ObjectIdentifier('1.2.840.113549.1.1.1' as List<int>),
      ); // rsaEncryption OID
      alg.add(ASN1Null());
      spki.add(alg);
      final pubKeyBytes =
          ASN1Sequence()
            ..add(ASN1Integer(publicKey.modulus!))
            ..add(ASN1Integer(publicKey.exponent!));
      spki.add(ASN1BitString(pubKeyBytes.encodedBytes));
      csrBuilder.add(spki);

      // Attributes (empty for simplicity, ZIMRA says optional)
      csrBuilder.add(ASN1Set());

      // Sign the CSR with the generated private key
      final signer = RSASigner(
        SHA256Digest(),
        '06092a864886f70d01010b',
      ); // OID for SHA256withRSA
      signer.init(true, PrivateKeyParameter<RSAPrivateKey>(privateKey));
      final csrHash = SHA256Digest().process(csrBuilder.encodedBytes);
      final signature = signer.generateSignature(csrHash);

      final signatureAlgorithm = ASN1Sequence();
      signatureAlgorithm.add(
        ASN1ObjectIdentifier('1.2.840.113549.1.1.11' as List<int>),
      ); // sha256WithRSAEncryption OID
      signatureAlgorithm.add(ASN1Null());

      final signedCsr = ASN1Sequence();
      signedCsr.add(csrBuilder);
      signedCsr.add(signatureAlgorithm);
      signedCsr.add(ASN1BitString(signature.bytes));

      final csrPem = _toPem(signedCsr.encodedBytes, 'CERTIFICATE REQUEST');

      // 3. Call registerDevice API
      final zimraApiClient =
          ZimraApiClient(); // Use a temporary client for this call
      final response = await zimraApiClient.registerDevice(
        deviceID: deviceId,
        activationKey: activationKey,
        deviceSerialNo: deviceSerialNo,
        certificateRequest: csrPem,
      );

      if (response != null && response['certificate'] != null) {
        final receivedCertPem = response['certificate'];

        // 4. Save the received certificate and the generated private key
        final appDir = await getApplicationDocumentsDirectory();
        final certFile = File('${appDir.path}/$_certFileName');
        final passwordFile = File('${appDir.path}/$_passwordFileName');

        // For simplicity, we'll save the received cert and the private key in a new P12
        // This requires a P12 builder, which is also complex.
        // A simpler approach for now: save the received cert PEM and the private key PEM separately.
        // Then, when loading, combine them or load them individually.
        // For this example, we'll just save the received cert PEM and assume the private key
        // is kept in memory for _signingPrivateKey.
        await certFile.writeAsString(receivedCertPem);
        await passwordFile.writeAsString(
          password,
        ); // Save the password for future loading

        // Set the loaded certificate and private key for the manager
        _certificatePath = certFile.path;
        _certificatePassword = password;
        _signingPrivateKey = privateKey; // Store the generated private key
        _securityContext = SecurityContext.defaultContext;
        _securityContext!.useCertificateChainBytes(
          Uint8List.fromList(receivedCertPem.codeUnits),
        );
        _securityContext!.usePrivateKeyBytes(
          Uint8List.fromList(privateKey.encodeToPem().codeUnits),
          password: password,
        );

        debugPrint('Device registered and certificate received successfully.');
        return {
          'certificate': receivedCertPem,
          'privateKeyPem': privateKey.encodeToPem(),
        };
      } else {
        debugPrint(
          'Register device failed: ${response?['message'] ?? 'Unknown error'}',
        );
        return null;
      }
    } catch (e, st) {
      debugPrint('Error generating CSR or registering device: $e\n$st');
      return null;
    }
  }

  // Helper to convert bytes to PEM format
  static String _toPem(Uint8List bytes, String type) {
    final base64 = hex.encode(
      bytes,
    ); // Should be base64.encode(bytes) but asn1lib.encode() returns hex
    final buffer = StringBuffer();
    buffer.writeln('-----BEGIN $type-----');
    for (var i = 0; i < base64.length; i += 64) {
      buffer.writeln(
        base64.substring(i, i + 64 > base64.length ? base64.length : i + 64),
      );
    }
    buffer.writeln('-----END $type-----');
    return buffer.toString();
  }
}

// Extend PointyCastle RSA private key to encode to PEM
extension RSAPrivateKeyPem on RSAPrivateKey {
  String encodeToPem() {
    final sequence = ASN1Sequence();
    sequence.add(ASN1Integer(BigInt.from(0))); // Version
    sequence.add(ASN1Integer(modulus!));
    sequence.add(ASN1Integer(exponent!)); // Public exponent
    sequence.add(ASN1Integer(privateExponent!));
    sequence.add(ASN1Integer(p!));
    sequence.add(ASN1Integer(q!));
    // Calculate Chinese Remainder Theorem (CRT) components
    final dP = privateExponent! % (p! - BigInt.one);
    final dQ = privateExponent! % (q! - BigInt.one);
    final qInv = q!.modInverse(p!);
    sequence.add(ASN1Integer(dP));
    sequence.add(ASN1Integer(dQ));
    sequence.add(ASN1Integer(qInv));

    final pkcs8 = ASN1Sequence();
    pkcs8.add(ASN1Integer(BigInt.from(0))); // Version
    final algId = ASN1Sequence();
    algId.add(
      ASN1ObjectIdentifier('1.2.840.113549.1.1.1' as List<int>),
    ); // rsaEncryption
    algId.add(ASN1Null());
    pkcs8.add(algId);
    pkcs8.add(ASN1OctetString(sequence.encodedBytes));

    return CertificateManager._toPem(pkcs8.encodedBytes, 'PRIVATE KEY');
  }
}

// Extend PointyCastle RSA public key to encode to PEM (for CSR)
extension RSAPublicKeyPem on RSAPublicKey {
  String encodeToPem() {
    final sequence = ASN1Sequence();
    sequence.add(ASN1Integer(modulus!));
    sequence.add(ASN1Integer(exponent!));

    final algId = ASN1Sequence();
    algId.add(
      ASN1ObjectIdentifier('1.2.840.113549.1.1.1' as List<int>),
    ); // rsaEncryption
    algId.add(ASN1Null());

    final spki = ASN1Sequence();
    spki.add(algId);
    spki.add(ASN1BitString(sequence.encodedBytes));

    return CertificateManager._toPem(spki.encodedBytes, 'PUBLIC KEY');
  }
}
